package banister

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"os"
	"path/filepath"
)

type GenerateConfig struct {
	PackageName string
	OutputDir   string
	Models      []Model
	MultiFile   bool
}

func Generate(c *GenerateConfig) error {
	files := generateJen(c)
	err := os.MkdirAll(c.OutputDir, 0755)
	if err != nil {
		return err
	}

	for name, f := range files {
		err = f.Save(filepath.Join(c.OutputDir, name))
		if err != nil {
			return err
		}
	}

	fmt.Println("Generated source to", c.OutputDir)
	return nil
}

func GenerateToString(c *GenerateConfig) string {
	for _, f := range generateJen(c) {
		// Only take the first one
		return f.GoString()
	}

	panic("No files generated")
}

func generateJen(c *GenerateConfig) map[string]*jen.File {
	files := make(map[string]*jen.File)
	file := func(name string) *jen.File {
		if !c.MultiFile {
			name = "Gen"
		}

		name = strcase.ToSnake(name) + ".go"
		if f, ok := files[name]; ok {
			return f
		}

		f := jen.NewFilePathName(c.OutputDir, c.PackageName)
		f.ImportAlias("github.com/Masterminds/squirrel", "sq")
		f.PackageComment("Code generated by banister; DO NOT EDIT.")
		files[name] = f
		return f
	}
	mFile := func(name string) *jen.File {
		return file("model_" + name)
	}

	// Generate things per model
	NewStoreGenerator(file(globalNames.StoreStruct), c.Models).Generate()
	for _, m := range c.Models {
		NewModelGenerator(mFile(m.Settings().Names().ModelStruct), m).Generate()
		NewModelConfigGenerator(mFile(m.Settings().Names().ConfigStruct), m).Generate()
		NewManagerGenerator(mFile(m.Settings().Names().ManagerStruct), m).Generate()
		NewQuerysetGenerator(mFile(m.Settings().Names().QuerysetStruct), m).Generate()
		NewSettersGenerator(mFile(m.Settings().Names().QuerysetSetterOptionsStruct), m).Generate()
		NewOrderBysGenerator(mFile(m.Settings().Names().QuerysetOrderByOptionsStruct), m).Generate()
		NewFilterGenerator(mFile(m.Settings().Names().QuerysetFilterOptionsStruct), m).Generate()
	}

	return files
}
